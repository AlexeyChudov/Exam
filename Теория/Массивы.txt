Массив — это непрерывный участок памяти, содержащий последовательность объектов одинакового типа, обозначаемый одним именем.

Имя массива - указатель на его первый элемент, а также - идентификатор, используемый для обращения к элементам массива.

Адрес массива – адрес начального элемента массива.

Размер массива – количество элементов массива

Размер элемента – количество байт, занимаемых одним элементом массива.

Каждый элемент массива характеризуется тремя величинами:

адресом элемента — адресом начальной ячейки памяти, в которой расположен этот элемент;

индексом элемента (порядковым номером элемента в массиве);

значением элемента.


Графически расположение массива в памяти компьютера можно представить в виде непрерывной ленты адресов.

Изначально, после обЪяевления массива в нем хранится мусор.

Инициализация массива:

 int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
 int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};//При инициализации необязательно писать размерность массива.

если количество элементов, инициализирующих массив меньше его длины, то недостающие элементы будут нулями.

 int a[5] = {0};//массив нулей


В качестве размерности массива можно указать переменную, но рекомендуется использовать константу этапа компилляции.

Массивы и указатели тесно связаны, имя массива само себе является указателем на его первый элемент.
Также у них схожий синтаксис:

 int a[10];
 int *p = a;
 int el = a[3];a[3] эквивалентно *(a+3)
 int el2 = p+2;
 el = a+2;
 el2 = p[3];

Но все-таки между указателями и массивами есть различия. 
Массив - непосредственно указывает на первый элемент, указатель – переменная, которая хранит адрес первого элемента. 

#include <conio.h>
#include <stdio.h>
 
void main() {
    int A[5] = {1, 2, 3, 4, 5};
    int *p = A;
 
    printf("%d\n", *(A+1));
    printf("%d\n", *(p+1));
    getch();
}
Это правильный код, который будет работать. Дело в том, что компилятор подменяет массив на указатель. Данный пример работает, потому что мы действительно работаем с указателем (хотя помним, что массив отличается от указателя). То же самое происходит и при вызове функции. Если функция требует указатель, то можно передавать в качестве аргумента массив, так как он будет подменён указателем.

В си существует одна занимательная особенность. Если A[i] это всего лишь синтаксический сахар, и A[i] == *(A + i), то от смены слагаемых местами ничего не должно поменяться, т. е. A[i] == *(A + i) == *(i + A) == i[A]. Как бы странно это ни звучало, но это действительно так. Следующий код вполне валиден:


int a[] = {1, 2, 3, 4, 5};
printf("%d\n", a[3]);
printf("%d\n", 3[a]);


Массив указателей и указатель на массив:

    int *ptr[3];//ptr - это массив укзателей
    int (*ptr2)[3] = arr_2d;//указатель на массив из 3-х элементов
    printf("sizeof(ptr2) = %zu\n", sizeof(ptr2));//sizeof(ptr2) = 12


Многомерные массивы

Многомерный массив - массив массивов.

Двумерный массив - массив это массив, элементами которого являются одномерные массивы.

Инициализация:
int a_2d[2][3] = {{1, 2, 3}, {4, 5, 6}, { 7, 8, 9}};//Здесь размерности можно опустить
int a_2d[][] = {{1, 2, 3}, {4, 5, 6}, { 7, 8, 9}};

//или
int b_2d[2][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9} 


Обработку массивов удобно организовывать с помощью специальных функций. Для обработки массива в качестве аргументов функции необходимо передать адрес массива и его размер.

 Пример:
int func(int *x, int n)  // произведение четных элементов
{
  int p = 1;  // начальное значение произведения
  int i;
  for (i = 0; i<n; i++) 
  {
    if (x[i] % 2 == 0)  // остаток от деления на 2 равен 0?
      p = p * x[i];
  }
  return p;
}
// Главная функция
int main()
{
  int a[5]; // объявлен массив a из 5 элементов
  int i;
  int pr;
// Ввод элементов массива
  for (i = 0; i<5; i++)
  {
    printf("a[%d] = ", i);
    scanf("%d", &a[i]); // &a[i] - адрес i-го элемента массива
  }
  pr = func(a, 5); // вычисление произведения
  printf("\n pr = %d", pr); // вывод произведения четных элементов
  getchar(); getchar();
  return 0;
}




