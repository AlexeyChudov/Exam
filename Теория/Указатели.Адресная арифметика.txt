Указатель – это переменная, которая хранит адрес области памяти. Указатель, как и переменная, имеет тип. Синтаксис объявления указателей

<тип> *<имя>;

Например:
float *a;
long long *b;

Два основных оператора для работы с указателями – это оператор & взятия адреса, и оператор * разыменования. Рассмотрим простой пример.

#include <conio.h>
#include <stdio.h>
   
void main() {
    int A = 100;
    int *p;
 
    //Получаем адрес переменной A
    p = &A;
 
    //Выводим адрес переменной A
    printf("%p\n", p);
 
    //Выводим содержимое переменной A
    printf("%d\n", *p);
 
    //Меняем содержимое переменной A
    *p = 200;
 
    printf("%d\n", A);
    printf("%d", *p);
}
Константые указатели и указатели на константу:
    const int *ptr;//указатель на константу, с помощью него нельзя изменить значение, хранящееся в его адресе
    ptr = &x;
    *ptr = 10;//выведется предурпеждение, изменится значение x 
    int * const c_ptr = &y;//Константный указатель, его значение(указателя) менять нельзя, то есть он указывает на единожды присвоенную ему область памяти.
    c_ptr = ptr; //код приведет к ошибке


Адресная арифметика

К указателям могут применять некоторые арифметические операции (сложение, вычитание, инкремент, декремент)
Однако сами операции производятся немного иначе, чем с числами. И многое здесь зависит от типа указателя.
К указателю можно прибавлять целое число, и также можно вычитать из указателя целое число.
Кроме того, можно вычитать из одного указателя другой указатель.

Пример

#include <stdio.h>
 
int main(void)
{
    int n = 10;
     
    int *ptr = &n;
    printf("address=%p \t value=%d \n", (void*)ptr, *ptr);
     
    ptr++;
    printf("address=%p \t value=%d \n", (void*)ptr, *ptr);
     
    ptr--;
    printf("address=%p \t value=%d \n", (void*)ptr, *ptr);

    double d = 10.6;
    double *pd = &d;
    printf("Pointer pd: address=%p \n", (void*)pd);
    pd++;
    printf("Pointer pd: address=%p \n", (void*)pd);
         
    char c = 'N';
    char *pc = &c;
    printf("Pointer pc: address=%p \n", (void*)pc);
    pc++;
    printf("Pointer pc: address=%p \n", (void*)pc);

    //Вычитание указателей одного типа
    int a = 10;
    int b = 23;
    int *pa = &a;
    int *pb = &b;
    int c = pa - pb;    // разница между адресами
     
    printf("pa=%p \n", (void*)pa);
    printf("pb=%p \n", (void*)pb);
    printf("c=%d \n", c);
     
    return 0;
}
Добавление к указателю типа double числа 2

pd = pd + 2;

означает, что мы хотим перейти на два объекта double вперед, что подразумевает изменение адреса на 2 * 8 = 16 байт.

Вычитание из указателя типа char числа 3

pc = pc - 3;

означает, что мы хотим перейти на три объекта char назад, что подразумевает изменение адреса на 3 * 1 = 3 байта.

И в моем случае я получу следующий консольный вывод:

Pointer pd: address=0060FEA0
Pointer pd: address=0060FEB0
Pointer pc: address=0060FE9F
Pointer pc: address=0060FE9C

Результатом разности двух указателей является "расстояние" между ними. Например, в случае выше адрес из первого указателя на 4 больше, чем адрес из второго указателя (0x0060FE9C + 4 = 0x0060FEA0). Так как размер одного объекта int равен 4 байтам, то расстояние между указателями будет равно (0x0060FEA0 - 0x0060FE9C)/4 = 1.

    const int cst_num = 10;//Константная переменная
    int num = 1;//Неконстантная переменная

    const int * cst_p = &cst_num;//Указатель на константу инициализируется константой переменной
    int * p = &num;//Обыкновенный указатель инициализируется неконстантной переменной

    swap_int(cst_p, p);//Попытка поменять значения указателей между друг другом
    //Программа скомпилировалась, лишь с предупреждением о потере указателем константного квалификатора
	
    //*cst_p = 2;//Неправильно!
    //При попытке Компилляции такого кода появится ошибка, потому что то к чему переприсваивается значение должно быть левым модифицируемым значением, но не константой 	

    printf("cst_p: %p, p:%p, cst_p value: %d, p value: %d\n", cst_p, p, *cst_p, (*p));
	
    int arr[3][4];

    
    int * arr_el_p = *arr;

    printf("arr = %p, arr_el_p = %p, arr + 1 = %p, arr_el_p + 1 = %p\n", arr, arr_el_p, arr+1, arr_el_p+1);

Используя обыкновенный указатель можно изменить значение константной переменной, 
Используя константный указатель нельзя изменить значение области памяти, на которую он ссылается!

Важно!
Особенности указателей:
######################################################################################################################################################
операции *, ++ и -- имеют одинаковый приоритет и при размещении рядом выполняются справа налево.


Пример:

int a = 10;
int *pa = &a;
printf("pa: address=%p \t value=%d \n", (void*)pa, *pa);
int b = *pa++;      // инкремент адреса указателя
     
printf("b: value=%d \n", b);
printf("pa: address=%p \t value=%d \n", (void*)pa, *pa);

В выражении b = *pa++; сначала к указателю присваивается единица (то есть к адресу добавляется 4, так как указатель типа int). Затем так как инкремент постфиксный, с помощью операции разыменования возвращается значение, которое было до инкремента - то есть число 10. И это число 10 присваивается переменной b. В этом случае результат работы будет следующий:

pa: address=0060FEA4	value=10
b: value=10
pa: address=0060FEA8	value=6356648


Аналогично будет с префиксным инкрементом:

b = ++*pa;

В данном случае сначала с помощью операции разыменования получаем значение по адресу из указателя pa, к этому значению прибавляется единица. То есть теперь значение по адресу, который хранится в указателе, равно 11. Затем результат операции присваивается переменной b:

pa: address=0060FEA4	value=10
b: value=11
pa: address=0060FEA4	value=11


Изменим выражение:

b = *++pa;

Теперь сначала изменяет адрес в указателе, затем мы получаем по этому адресу значение и присваиваем его переменной b. Полученное значение в этом случае может быть неопределенным:

pa: address=0060FEA4	value=10
b: value=6356648
pa: address=0060FEA8	value=6356648
