Переменная - именованная или адресованная область виртуальной, т.е. логической или физической памяти(чаще виртуальной),
 которая хранит в себе значение определенного типа.

Переменная сначала объявляется  с указанием своего типа, может быть инициализированна при объявлении или после. 

int number;
int count = 0;


Присвоение значения переменной означает запись в отведенную этой переменной область памяти этого значения.

number = 10;

Переменной можно присвоить и переприсвоить любое значение указанного типа.


number = 11;


Функция sizeof(тип/переменная/массив) возвращает количество байт, оведенное под переданный тип, или кол-во байт, занимаемое переданным аргументом.

sizeof(char)//1
sizeof number//4

size_t - беззнаковый целый тип, предназначенный для представления размера любого объекта в памяти, включая массивы.

Квалификатор const используется при объявлении переменных и массивов, означает, что объвленный не может быть переопределён, т.е. константен

const int x = 10;

Значение константной переменной все-таки может быть изменено, при этом во время компиляции появится предупреждение



Перечисление - отдельный тип данных в си(enum), задающий набор всех возможных целочисленных значений переменной этого типа.  

int main(){

enum Types{
	Int, //0
	Float,//1
	Double = 1,//1
	Long//2
}

enum Types a, b, c;

a = Int;
return 0;
}

    Переменной типа Token нельзя присвоить просто численное значение. Переменная является сущностью типа Token и принимает только значения полей перечисления. Тем не менее, переменной числу можно присвоить значение поля перечисления.

Обычно, перечисления используются в качестве набора именованных констант. Часто создается массив строк, ассоциированных с полями перечисления, например:
#include <stdio.h>

enum Errors{
    INDEX_OUT_OF_BOUNDS = 1,
    STACK_OVERFLOW,
    STACK_UNDERFLOW,
    OUT_OF_MEMORY
    };

    char *NameErrors[] {
	"Index Out Of Bounds",
        "Stack Overflow",
        "Stack Underflow",
        "Out of Memory"
    };

int main(){

    puts(NameErrors[INDEX_OUT_OF_BOUNDS-1];
    exit(INDEX_OUT_OF_BOUNDS);//программа завершается с кодом 1, то есть с ошибкой
}

Чтобы постоянно не писать enum, можно объявить его, с помощью typedef
   
typedef enum enumName {
    FIELD1,
    FIELD2
} Name;

typedef enum Bool {
    FALSE,
    TRUE
} Bool;

Все операторы в Си в порядке убывания приоритета

1	++	Постинкремент (Suffix increment).	Слева - направо
--	Постдекремент (Suffix decrement).
()	Вызов функции.
[]	Индексация в массиве.
.	Выбор элемента структуры по ссылке.
->	Выбор элемента структуры по указателю.
typeid()	Информация о типе по время выполнения (Run-time type information, только для C++, см. typeid).
const_cast	Приведение типа (Type cast, только для C++ only, см. const_cast).
dynamic_cast	Приведение типа (только для C++, см. dynamic_cast).
reinterpret_cast	Приведение типа (Type cast, только для C++, см. reinterpret_cast).
static_cast	Приведение типа (Type cast, только для C++, см. static_cast).
3	++	Прединкремент (Prefix increment).	Справа - налево
--	Преддекремент (Prefix decrement).
+	Унарный плюс.
-	Унарный минус.
!	Логическое отрицание (NOT).
~	Побитное отрицание (Bitwise NOT, дополнение до единицы, One's Complement).
(type)	Преобразование типа (Type cast).
*	Выборка значения по ссылке (Indirection, dereference).
&	Операция взятия адреса (получение указателя).
sizeof	Получение размера объекта указанного типа (структуры, переменной и т. п.).
new, new[]	Динамическое выделение памяти под объект из кучи, создание объекта (только для C++).
delete, delete[]	Динамическое освобождение памяти, ранее выделенной под объект, удаления объекта (только для C++).
4	.*	Указатель на член (только для C++).	Слева - направо
->*	Указатель на член (только для C++).
5	*	Умножение.	Слева - направо
/	Деление.
%	Взятие по модулю числа (Modulo, получение остатка от деления).
6	+	Сложение.	Слева - направо
-	Вычитание.
7	<<	Побитный сдвиг влево (Bitwise left shift).	Слева - направо
>>	Побитный сдвиг вправо (Bitwise right shift).
8	<	Меньше чем...	Слева - направо
<=	Меньше или равно...
>	Больше чем...
>=	Больше или равно...
9	==	Оператор определения равенства (Equal to).	Слева - направо
!=	Оператор определения неравенства (Not equal to)
10	&	Побитная операция И (Bitwise AND)	Слева - направо
11	^	Побитная операция Исключающее ИЛИ (Bitwise XOR, exclusive or).	Слева - направо
12	|	Побитная операция ИЛИ (Bitwise OR, inclusive or).	Слева - направо
13	&&	Логическая операция И (AND).	Слева - направо
14	||	Логическая операция ИЛИ (OR).	Слева - направо
15	?:	Тернарный оператор (Ternary conditional, см. ?:).	Справа - налево
16	=	Прямое присваивание.	Справа - налево
+=	Присваивание со сложением.
-=	Присваивание с вычитанием.
*=	Присваивание с умножением.
/=	Присваивание с делением.
%=	Присваиванием с взятием остатка от деления.
<<=	Присваивание со побитным сдвигом влево.
>>=	Присваивание с побитным сдвигом вправо.
&=	Присваивание с побитным AND.
^=	Присваивание с побитным XOR.
|=	Присваивание с побитным OR.










